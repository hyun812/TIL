## 이벤트 전파

`HTML` 태그의 `계층적` 구조 특징으로 인해 이벤트가 발생할 경우 `연쇄적` `이벤트 흐름`이 발생하는데 이러한 현상을 `이벤트 전파`라고 함

> **전파 방향에 따라 버블링과 캡처링으로 구분함**

<br/>

**표준 DOM 이벤트에서 정의한 이벤트 흐름 3가지 단계**

1. **캡처링 단계** : 이벤트가 하위 요소로 전파되는 단계
2. **타깃 단계** : 이벤트가 실제 타깃 요소에 전달되는 단계
3. **버블링 단계** : 이벤트가 상위 요소로 전파되는 단계

<br/>

### 이벤트 전파 제어

부모와 자식 둘다 이벤트를 등록한 상태에서, 자식 요소의 이벤트만 발생시키고 부모 요소의 이벤트는 발생시키고 싶지 않을때 `이벤트 전파`를 `방지`하는 식으로 해결해야 함

1. **e.stopPropagation() - 이벤트 전파 중지**
2. **e.stopImmediatePropagation() - 이벤트 전파 중지 + 형제 이벤트 실행 중지**
3. **e.target으로 조건을 걸어 방지**
4. **e.preventDefault() - 이벤트 전파 중지 + 형제 이벤트 실행 중지 + 이벤트 기본 동작 중지**

<br/>

## 이벤트 위임

**하나의 상위 요소에 이벤트 핸들러를 등록하여 여러개의 하위 요소 이벤트들을 제어하는 방식**

**DOM 이벤트에 적용할 수 있는 패턴**

```jsx
<ul id="post-list">
  <li id="post-1">Item 1</li>
  <li id="post-2">Item 2</li>
  <li id="post-3">Item 3</li>
</ul>;

const list = document.querySelector('ul');

list.addEventListener('click', (e) => {
  if (e.target.tagName === 'li') {
    console.log(e.target.innerText);
  }
});
```

- 동적으로 생성되는 요소나 여러 하위 요소를 비슷한 방식으로 다루는 경우 용이함

<br/>

### 동작과정

1. 공통되는 부모에 이벤트 핸들러를 할당함
2. 핸들러의 `event.target`을 이용해 이벤트가 발생한 요소가 어디인지 알아냄
3. 원하는 요소에서 이벤트가 발생했다고 확인되면 이벤트를 핸들링

<br/>

### 장점

- 다수의 이벤트 핸들러를 할당하는 대신에 하나의 이벤트 핸들러만 할당하기 때문에, 코드가 단순해지고 메모리가 절약된다.
- 요소가 추가되거나 제거되는 동작이 많은 경우에도 짧은 코드만으로 이벤트 처리가 가능하다

<br/>

### 단점

- 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소 인지 확인해야 함 (이벤트 타킷)
- 이벤트 위임을 사용하기 위해 이벤트가 `반드시` `버블링`되어야 함
- focus 이벤트나 stopPropagation() 등을 사용한 경우에는 이벤트 위임을 사용할 수 없음

### 참고

- #### 버블링을 막아야 하는 경우는 거의 없음

- #### event.target과 this(=event.currentTarget)의 차이점

  - event.target은 실제 이벤트가 시작된 `타깃` 요소로 버블링이 진행되어도 변하지 않음
  - this(=event.currentTarget)는 `현재` 요소로, 현재 실행 중인 핸들러가 할당된 요소를 참조
